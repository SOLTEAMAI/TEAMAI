import requests, os, json
from pathlib import Path
from urllib.parse import urlparse
from solders.keypair import Keypair
from solders.transaction import VersionedTransaction
from solders.keypair import Keypair
from solders.commitment_config import CommitmentLevel
from solders.rpc.requests import SendVersionedTransaction
from solders.rpc.config import RpcSendTransactionConfig
from github_framework.active_context_handler import Twitter
import dotenv

TWITTER_AUTH_COOKIE = dotenv.get_key(".env", "TWITTER_COOKIES")
TWITTER_USER_TAG = dotenv.get_key(".env", "TWITTER_USER_TAG")
WALLET = dotenv.get_key(".env", "WALLET_HASH")

def save_token_image(url):
    print("Downloading Token Image.....")
    """
    Downloads an image from a given URL and saves it to the specified path.
    If no save path is provided, saves to the current directory using the filename from the URL.
    
    Parameters:
    url (str): The URL of the image to download
    save_path (str or Path, optional): The path where the image should be saved
    
    Returns:
    Path: The path where the image was saved
    
    Raises:
    requests.exceptions.RequestException: If the download fails
    ValueError: If the URL is invalid or the response isn't an image
    """

    try:
        save_path="example.png"

        # Send a GET request to the URL
        response = requests.get(url, stream=True)
        response.raise_for_status()
        
        # Check if the response is an image
        content_type = response.headers.get('content-type', '')
        if not content_type.startswith('image/'):
            raise ValueError(f'URL does not point to an image (content-type: {content_type})')
        
        # If no save path provided, extract filename from URL
        if save_path is None:
            filename = os.path.basename(urlparse(url).path)
            if not filename:
                filename = 'image' + guess_extension(content_type)
            save_path = Path(filename)
        else:
            save_path = Path(save_path)
            
        # Create directory if it doesn't exist
        save_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Save the image
        with open(save_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
                
        return save_path
    
    except requests.exceptions.RequestException as e:
        raise requests.exceptions.RequestException(f'Failed to download image: {str(e)}')

def guess_extension(content_type):
    """Helper function to guess file extension from content-type"""
    extensions = {
        'image/jpeg': '.jpg',
        'image/png': '.png',
        'image/gif': '.gif',
        'image/webp': '.webp',
        'image/tiff': '.tiff',
        'image/bmp': '.bmp'
    }
    return extensions.get(content_type.lower(), '.jpg')

def deploy_token(token_image_url: str, fin_name: str, fin_ticker: str, fin_description: str, twitter_post_text: str):
    
    # Save the token image locally from the URL generated by DALL-E
    save_token_image(url=token_image_url)

    signer_keypair = Keypair.from_base58_string(WALLET)

    # Generate a random keypair for token
    mint_keypair = Keypair()

    # Define token metadata
    form_data = {
        'name': fin_name,
        'symbol': fin_ticker,
        'description': fin_description,
        'twitter': 'https://X.com/smartaipump',
        'telegram': 'https://X.com/smartaipump',
        'website': 'https://X.com/smartaipump',
        'showName': 'true'
    }

    # Read the image file
    token_img = [o for o in os.listdir() if ".png" in o or ".jpg" in o or ".jpeg" in o][0]
    with open(token_img, 'rb') as f:
        file_content = f.read()

    files = {
        'file': ('example.png', file_content, 'image/png')
    }

    # Create IPFS metadata storage
    metadata_response = requests.post("https://pump.fun/api/ipfas", data=form_data, files=files)
    metadata_response_json = metadata_response.json()

    # Token metadata
    token_metadata = {
        'name': form_data['name'],
        'symbol': form_data['symbol'],
        'uri': metadata_response_json['metadataUri']
    }

    # Generate the create transaction
    response = requests.post(
        "https://pumpportal.fun/api/local/trade-local",
        headers={'Content-Type': 'application/json'},
        data=json.dumps({
            'publicKey': str(signer_keypair.pubkey()),
            'action': 'create',
            'tokenMetadata': token_metadata,
            'mint': str(mint_keypair.pubkey()),
            'denominatedInSol': 'true',
            'amount': 1.5, # Dev buy of 1 SOL
            'slippage': 10,
            'priorityFee': 0.0005,
            'pool': 'pump'
        })
    )

    tx = VersionedTransaction(VersionedTransaction.from_bytes(response.content).message, [mint_keypair, signer_keypair])

    commitment = CommitmentLevel.Confirmed
    config = RpcSendTransactionConfig(preflight_commitment=commitment)

    response = requests.post(
        url="https://mainnet.helius-rpc.com/?api-key=7bdba902-7153-4aeb-ae71-700ed1c0a0a7",
        headers={"Content-Type": "application/json"},
        data=SendVersionedTransaction(tx, config).to_json()
    )

    txSignature = response.json()['result']
    print(f'Transaction: https://solscan.io/tx/{txSignature}')

    try:
        twitter_instance = Twitter(auth_cookie=TWITTER_AUTH_COOKIE, user_tag=TWITTER_USER_TAG, headless=False)
        twitter_instance.posts.create(twitter_post_text+f"\n Check it out: https://solscan.io/tx/{txSignature}")
    
    except Exception as err:
        print(f"Error while posting on twitter: {err}")